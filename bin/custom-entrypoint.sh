#!/usr/bin/env bash
set -e
#set -x

PSQL_CONFIG_FILE="${PGDATA}/postgresql.conf"
PSQL_TEMPLATE_CONFIG_FILE='/usr/local/etc/postgresql.conf'
PSQL_CUSTOM_CONFIG_FILE="${PGDATA}/postgresql.local.conf"

RECOVERY_CONFIG_FILE="${PGDATA}/recovery.conf"
RECOVERY_TEMPLATE_CONFIG_FILE='/usr/local/etc/recovery.conf'

PG_HBA_CONFIG_FILE="${PGDATA}/pg_hba.conf"

if [[ -z "${REPLICATION_USER}" ]]; then
  REPLICATION_USER='replication'
fi
if [[ -z "${REPLICATION_PASS}" ]]; then
  REPLICATION_PASS='replication'
fi

echo '[custom-entrypoint] enter'


echo '[custom-entrypoint] check whether is master instance or not'
if [[ "x$(hostname)" == "x${REPLICATION_UPSTREAM_HOST}" -o "x$HOST)" == "x${REPLICATION_UPSTREAM_HOST_IP}" ]]; then
  echo '  ... master'
  MASTER_INSTANCE=true
else
  echo '  ... slave'
  MASTER_INSTANCE=false
fi


# --
# copy custom config
# add custom options to config
# --

echo
echo '[custom-entrypoint/configure] generate auto config'
echo "
#
#------------------------------------------------------------------------------
# DOCKER AUTOGENERATED via system settings
#------------------------------------------------------------------------------
" >> "${PSQL_CUSTOM_CONFIG_FILE}"

shared_buffers=$(grep MemTotal /proc/meminfo | awk '{print $2}')
shared_buffers=$(( shared_buffers / 4098 ))

maintenance_work_mem=$(( shared_buffers / 10 ))
[ $maintenance_work_mem -gt 1024 ] && maintenance_work_mem=1024
[ $maintenance_work_mem -lt 64 ] && maintenance_work_mem=64

echo "

shared_buffers = ${shared_buffers}MB  # shared_buffers set to 25% of TotalMemory

work_mem = 64MB # do not write temp file on disk

# Сбор статитстики по запросам для Okmeter и ручного анализа (можно выключить но на скорость оно особое не влияет).

shared_preload_libraries         = 'pg_stat_statements'
pg_stat_statements.max           = 10000
pg_stat_statements.track         = top
pg_stat_statements.track_utility = true
pg_stat_statements.save          = false

maintenance_work_mem = ${maintenance_work_mem}MB

# Более разумные настройки для ssd:
vacuum_cost_page_hit   = 0        # 0-10000 credits
vacuum_cost_page_miss  = 10       # 0-10000 credits
vacuum_cost_page_dirty = 10       # 0-10000 credits

# Для большой нагруженной базы - только так правильно:
bgwriter_delay          = 10ms    # 10-10000 ms between rounds
bgwriter_lru_maxpages   = 1000    # 0-1000 max buffers written/round
bgwriter_lru_multiplier = 10.0    # 0-10.0 multipler on buffers scanned/round

# Не надо диски даже ssd checkpoints мучать:
max_wal_size = 12GB
checkpoint_timeout  = 60min
wal_keep_segments = 256

# Для лучшего понимания, что на базе творится:
log_checkpoints = on
log_lock_waits  = on
log_temp_files  = 0

#
autovacuum_max_workers         = 3          # +1 воркер на каждые 50Gb базы
autovacuum_vacuum_scale_factor = 0.05       # fraction of table size before vacuum
autovacuum_vacuum_cost_delay   = 5ms        # default vacuum cost delay for

# commit на ssd
commit_delay = 0

# slow query
log_min_duration_statement = 1000ms

random_page_cost = 1.2      # SSD disks, old value 4.0 

effective_io_concurrency = 2    # Raid with 2 disks

autovacuum_vacuum_threshold  = 500      # Это должно уменьшить реакцию autovacuum
autovacuum_analyze_threshold = 200

" >> "${PSQL_CUSTOM_CONFIG_FILE}"

echo
echo '[custom-entrypoint/configure] build custom config'
echo "[custom-entrypoint/configure] copy ${PSQL_TEMPLATE_CONFIG_FILE} to ${PSQL_CONFIG_FILE}"
cp "${PSQL_TEMPLATE_CONFIG_FILE}" "${PSQL_CONFIG_FILE}"

echo "[custom-entrypoint/configure] configure ${PSQL_CUSTOM_CONFIG_FILE}"
echo "
#
#------------------------------------------------------------------------------
# DOCKER AUTOGENERATED FROM ENVIRONMENT VARIABLE POSTGRES_CUSTOM_CONFIG
#------------------------------------------------------------------------------
" >> "${PSQL_CUSTOM_CONFIG_FILE}"

IFS=',' read -ra CONFIG_PAIRS <<< "${POSTGRES_CUSTOM_CONFIG}"
for CONFIG_PAIR in "${CONFIG_PAIRS[@]}"
do
    IFS=':' read -ra CONFIG <<< "${CONFIG_PAIR}"
    VAR="${CONFIG[0]}"
    VAL="${CONFIG[1]}"
    echo "[custom-entrypoint/configure] adding config '${VAR}'='${VAL}' "
    echo "${VAR} = ${VAL}" >> "${PSQL_CUSTOM_CONFIG_FILE}"
done


# --
# add pg_hba replication entry
# --
echo
echo '[custom-entrypoint/pg_hba] add pg_hba entry for replication user'
echo -e "host\treplication\t${REPLICATION_USER}\t0.0.0.0/0\tmd5" >> "${PG_HBA_CONFIG_FILE}"


# --
# master/slave main logic
# --
if ${MASTER_INSTANCE}; then
  # --
  # add replication user
  # --
  echo
  echo "[custom-entrypoint/master] create replication user '${REPLICATION_USER}'"
  psql -U "${POSTGRES_USER}" -c "CREATE ROLE ${REPLICATION_USER} WITH REPLICATION PASSWORD '${REPLICATION_PASS}' LOGIN"
else
  # --
  # build and copy recovery.conf
  # --

  if [[ -z "${REPLICATION_UPSTREAM_HOST}" -a -z "${REPLICATION_UPSTREAM_HOST_IP}" ]]; then
    echo '[!ERROR!] instance ought to be a slave, but $REPLICATION_UPSTREAM_HOST or $REPLICATION_UPSTREAM_HOST_IP is not set'
    exit
  fi

  if [[ -n "${REPLICATION_UPSTREAM_HOST_IP}" ]]; then
    echo
    echo "[custom-entrypoint/set ip addres] REPLICATION_UPSTREAM_HOST set to $REPLICATION_UPSTREAM_HOST_IP"
    REPLICATION_UPSTREAM_HOST=${REPLICATION_UPSTREAM_HOST_IP}
  fi

#  echo '[custom-entypoint/slave] copy recovery.conf'
#  cp "${RECOVERY_TEMPLATE_CONFIG_FILE}" "${RECOVERY_CONFIG_FILE}"

#  echo '[custom-entrypoint/slave] build connifo property'
#  CONN_INFO="primary_conninfo = 'user=${REPLICATION_USER} password=${REPLICATION_PASS} port=5432 sslmode=prefer sslcompression=1 krbsrvname=postgres host=${REPLICATION_UPSTREAM_HOST} application_name=$(hostname)'"
#  sed "s/^#primary_conninfo.*/${CONN_INFO}/" -i "${RECOVERY_CONFIG_FILE}"

  echo
  echo '[custom-entrypoint/slave] stop psql and clean up $PGDATA'
  pg_ctl -D "${PGDATA}" -m fast -w stop
  rm -rf "${PGDATA}"/*

  echo '[custom-entrypoint/slave] copy master database'
  PGPASSWORD=${REPLICATION_PASS} pg_basebackup -h "${REPLICATION_UPSTREAM_HOST}" -U "${REPLICATION_USER}" -P -R -D "${PGDATA}"
  echo "trigger_file='${PGDATA}/start_master'" >> "${PGDATA}/recovery.conf"

  pg_ctl -D "${PGDATA}" -w start
fi
